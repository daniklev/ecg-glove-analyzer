package commwellmedical.com.gloveecgservice;

/* Created by Alex Levshin on 28/08/2015.
    Unit : UtilsClass
    Finished:
    Status: Not Complete
    Version: 1.0
    Description:
    FD :
    Bugs : none
    Updates : test - xamarin
    */

import android.annotation.TargetApi;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Bundle;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.TimeUnit;

import static commwellmedical.com.gloveecgservice.ECG12_protocol.BATT_LEVEL_LENGTH;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.DATA_LENGTH;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.FAULT_DATA_LENGTH;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_BATT_LEVEL_CMD;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_DATA_TRASFER_TYPE;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_DESTINATION;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_FAULT_TRASFER_TYPE;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_GLOVE_TYPE;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_GLOVE_VERSION;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_INDX_DATA_CHKSUM;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_INDX_DATA_LENGTH;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_INDX_DESTINATION;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_INDX_SEQ_LSB;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_INDX_SEQ_MSB;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_INDX_SOURCE;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_INDX_TRASFER_TYPE;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_LENGTH;
import static commwellmedical.com.gloveecgservice.ECG12_protocol.HEADER_SOURCE;

public class EcgBluetoothLink {

    //region message declaration
    static final int OK_BLUETOOTH_CONNECTED = 2;
    static final int OK_BLUETOOTH_ADAPTER_READY_TO_CONNECT = 1;
    static final int ERROR_BLUETOOTH_NOT_PAIRED = 0;
    static final int ERROR_BLUETOOTH_ADAPTER_NOT_AVAILABLE = -1;
    static final int ERROR_BLUETOOTH_ADAPTER_DISABLE = -2;
    static final int ERROR_BLUETOOTH_NAME_EMPTY = -3;
    static final int ERROR_BLUETOOTH_CONNECTION = -4;


    public double battfLevel = 0;
    public double LevelBattHi = 4;
    public double LevelBattMed = 3.8;
    public double LevelBattLow = 3.65;

    public static String PREF_ECG_FOLDER = "EcgFolder";
    public static String PREF_ECG_DISPLAY_TYPE = "0";
    public static String PREF_ECG_LONG_LEAD = "1";
    public static String PREF_ECG_POWER_FREQ = "50";
    public static String PREF_ECG_HI_PASS = "0";
    public static String PREF_ECG_PRE_REC_TIME = "5";
    public static String PREF_ECG_REC_TIME = "10";
    public static String PREF_ECG_SENSITIVITY = "1";
    public static String PREF_ECG_RANGE = "10"; //5
    public static String PREF_ECG_AUTO_STOP = "6"; //5
    public static String PREF_ECG_SPIKE_REMOVE = "true"; //5

    private static int TIME_OUT_WAIT_RECORDING_SEC = 300;
    private static int TIME_OUT_NEXT_MESSAGE_SEC = 30;
    private static int SENS_HI_WAIT_SEC = 30;
    private static int SENS_MED_WAIT_SEC = 210;
    private static int MARTIX_DELAY_SEC_BEFORE_SEND = 20;

    private static int SENS_HI_MISS_LEADS = 0;
    private static int SENS_MED_MISS_LEADS = 1;
    private static int SENS_LOW_MISS_LEADS = 2;

    //endregion

    //region variable declaration

    private static final UUID SPP_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
    private final String LOG_TAG = getClass().getSimpleName();
    private BluetoothSocket blueToothSocket;

    private boolean bluetoothConnected;
    private BluetoothAdapter bluetoothadapter;
    public  String  hardwareVersion;

    String bluetoothName = "";
    String sens_level = "0";
    String power_line = "50";  //default power line freq for ECG
 //   String rec_time = "10";    // default total recording time   in sec
//    String pre_rec_time = "5";  // default wait for ecg data in base line range in sec
   // sensitivity level ( number of missing V leads in for recording ECG )
 //   String ecg_range = "5";   // base line range  in mV
 //   String rep_type = "1";    // report type generated by service in PNG  3x4 or 6x2
//    String long_lead = "1";   // number of long strip use in report
    String filter_type = "0"; //  type of filter use in report
//    String spike_removal_filter = "true";
    ECG12_protocol ecgProtocol;

    private BluetoothDevice bluetoothdevice = null;
    private SharedPreferences settings;

    private Thread threadParceringBluetoothData = null;
    private Thread threadCaptureBluetoothData = null;
    private Thread threadAssistantEcgData = null;
    private boolean isAssistEcgStateOn = false;
    private boolean isCaptureBluetoothThreadOn = false;
    private boolean isParserThreadOn = false;
 //   private ReentrantLock lock = new ReentrantLock();

    private volatile boolean inReadMode = false;  // flag input raw data buffer in parcering function- prevent to double reading
    private ArrayBlockingQueue inBtQueue;  // input raw data buffer
    private ArrayBlockingQueue inParcerQueue; // parcered data
    public ArrayBlockingQueue rawData; // parcered data

    private AssistEcgState currentAssistEcgState = AssistEcgState.START_ASSIST;
    private AssistEcgState prevAssistEcgState;
    private volatile int saveIndexBeforeRemove;

    private int THREAD_SLEEP = 20;  // in ms  old value 20
    private int SLEEP_CAPTURE_DATA = 2; //old value 300;
    private int sleepCaptureData = SLEEP_CAPTURE_DATA;
    private int INQUEUE_BUFFER_LENGTH = 8096 * 1;
    private int prevPacket = 0;
    private int currPack = 0;

    EcgDataView ecgDataView;
    private Context mContext;
    private EcgDataService srv;

    //endregion

    public EcgBluetoothLink(EcgDataService _srv) {
        inBtQueue = new ArrayBlockingQueue<Byte>(INQUEUE_BUFFER_LENGTH);
        inParcerQueue = new ArrayBlockingQueue<Byte>(INQUEUE_BUFFER_LENGTH);
        rawData =  new ArrayBlockingQueue<Byte>(2000*1000);
        srv = _srv;
        ecgDataView = new EcgDataView(srv);
        ecgProtocol = new ECG12_protocol();
        LogMe.d(LOG_TAG, "Create EcgBluetoothLink");
    }


    public void FreeAndClose() {
        LogMe.w(LOG_TAG, "Destroy EcgBluetoothLink !!!");
        ecgProtocol.FreeAndClose();
        ecgProtocol = null;
        ecgDataView.FreeAndDestroy();  //DODO check now  !!!
        ecgDataView = null;
        inBtQueue.clear();
        rawData.clear();
        inParcerQueue.clear();
        inBtQueue = null;
        rawData = null;
        inParcerQueue = null;
    }

    public void SetContext(Context ctx) {
      /*  mContext = ctx;
        settings = PreferenceManager.getDefaultSharedPreferences(mContext);
        bluetoothName = settings.getString("glove_name", "");
        rep_type = settings.getString("ecg_display_type_report", PREF_ECG_DISPLAY_TYPE);
        long_lead = settings.getString("ecg_rhytm_strip", PREF_ECG_LONG_LEAD);
        power_line = settings.getString("power_freq", PREF_ECG_POWER_FREQ);
        filter_type = settings.getString("filter_type", PREF_ECG_HI_PASS);
        pre_rec_time = settings.getString("ecg_pre_rec_time", PREF_ECG_PRE_REC_TIME);
        rec_time = settings.getString("ecg_rec_time", PREF_ECG_REC_TIME);
        sens_level = settings.getString("ecg_sencitivity_level", PREF_ECG_SENSITIVITY);
        ecg_range = settings.getString("ecg_range", PREF_ECG_RANGE);*/
       /* bluetoothName = "ET KD150000";
        rep_type =  PREF_ECG_DISPLAY_TYPE;
        long_lead =  PREF_ECG_LONG_LEAD;
        power_line =  PREF_ECG_POWER_FREQ;
        filter_type =  PREF_ECG_HI_PASS;
        pre_rec_time =  PREF_ECG_PRE_REC_TIME;
        rec_time =  PREF_ECG_REC_TIME;
        sens_level =  PREF_ECG_SENSITIVITY;
        ecg_range =  PREF_ECG_RANGE;*/
    }

    public boolean WriteGloveNameToSettings(String gloveName,String folderEcg) {
        bluetoothName = gloveName;
        PREF_ECG_FOLDER = folderEcg;
        return true;
/*        settings = PreferenceManager.getDefaultSharedPreferences(mContext);
        SharedPreferences.Editor ed = settings.edit();
        ed.commit(); //TODO  change to .apply
        ed.putString("glove_name", gloveName);
        ed.commit();
        settings.edit().putString("glove_name", gloveName);
        LogMe.w(LOG_TAG, "Commit done");
        return settings.edit().commit();*/
    }

    //  return int value
    //         OK_BLUETOOTH_CONNECTED
    //         OK_BLUETOOTH_ADAPTER_READY_TO_CONNECT
    //         ERROR_BLUETOOTH_NOT_PAIRED
    //         ERROR_BLUETOOTH_ADAPTER_NOT_AVAILABLE
    //         ERROR_BLUETOOTH_ADAPTER_DISABLE
    //         ERROR_BLUETOOTH_NAME_EMPTY

    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
    protected int isGloveAvailableToConnect() {

        try {
            bluetoothadapter = BluetoothAdapter.getDefaultAdapter();
        } catch (Exception e) {
            return ERROR_BLUETOOTH_ADAPTER_NOT_AVAILABLE;
        }

        if (bluetoothadapter == null)
            return ERROR_BLUETOOTH_ADAPTER_NOT_AVAILABLE;

        if (!bluetoothadapter.isEnabled())
            return ERROR_BLUETOOTH_ADAPTER_DISABLE;

        if (bluetoothName.isEmpty())
            return ERROR_BLUETOOTH_NAME_EMPTY;

        if (bluetoothConnected)
            return OK_BLUETOOTH_CONNECTED;

        LogMe.d(LOG_TAG, "bluetoothadapter.getBondedDevices()");

        Set<BluetoothDevice> pairedDevices = bluetoothadapter.getBondedDevices(); // If there are paired devices
        if (pairedDevices != null)
            if (pairedDevices.size() > 0) {  // Loop through paired devices
                for (BluetoothDevice device : pairedDevices) {
                    LogMe.w(LOG_TAG, "Test device  : " + device.toString());
                    String DeviceName = device.getName().toUpperCase().trim();
                    if (DeviceName.equals(bluetoothName.toUpperCase().trim())) {
                        LogMe.d(LOG_TAG, "Found Glove : " + bluetoothName);
                        bluetoothdevice = device;
                        return OK_BLUETOOTH_ADAPTER_READY_TO_CONNECT;
                    }
                }
            }

        LogMe.w(LOG_TAG, "NOT Found Glove : " + bluetoothName);
        return ERROR_BLUETOOTH_NOT_PAIRED;
    }

    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
    public boolean isBtConnected() {
        return blueToothSocket != null && blueToothSocket.isConnected();
    }

    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
    protected int ConnectToBT() {
        LogMe.d(LOG_TAG, "Try to connect to BluetoothName: " + bluetoothName + bluetoothadapter + " " + bluetoothdevice);

        if (bluetoothadapter == null)
            return ERROR_BLUETOOTH_ADAPTER_NOT_AVAILABLE;
        if (!bluetoothadapter.isEnabled())
            return ERROR_BLUETOOTH_ADAPTER_DISABLE;
        if (bluetoothName.isEmpty())
            return ERROR_BLUETOOTH_NAME_EMPTY;
        if (bluetoothdevice == null)
            return ERROR_BLUETOOTH_NOT_PAIRED;

        try {
            LogMe.i(LOG_TAG, "Check BT status " + bluetoothConnected + "/" + ecgProtocol.isLastSendOk);
            if (blueToothSocket != null) {
                if (bluetoothConnected || !ecgProtocol.isLastSendOk) {
                    LogMe.w(LOG_TAG, "Restart BT");
                    blueToothSocket.close();
                    blueToothSocket = null;
                }
            }

            if (blueToothSocket == null) {
                LogMe.w(LOG_TAG, "bluetoothdevice== null");
                blueToothSocket = bluetoothdevice.createRfcommSocketToServiceRecord(SPP_UUID);
                LogMe.d(LOG_TAG, "bluetoothdevice.createRfcommSocketToServiceRecord");
            }
            if (!blueToothSocket.isConnected()) {
                LogMe.d(LOG_TAG, " start/try to connect blueToothSocket.connect()");
                try {
                    blueToothSocket.connect();
                } catch (Exception e) {
                    LogMe.e(LOG_TAG, " Error on blueToothSocket.connected end"+e.getMessage());
                    return ERROR_BLUETOOTH_CONNECTION;
                }
                LogMe.d(LOG_TAG, " blueToothSocket.connected end");
            }

            ecgProtocol.UpdateBluetoothSocket(blueToothSocket);
            LogMe.d(LOG_TAG, "UpdateBluetoothSocket");
            EnableCaptureBluetoothThread(true);
            LogMe.d(LOG_TAG, "EnableCaptureBluetoothThread");
            EnableParserThread(true);
            LogMe.d(LOG_TAG, "EnableParserThread");
            return OK_BLUETOOTH_CONNECTED;
        } catch (IOException e1) {
            LogMe.e(LOG_TAG, "ConnectToBT end with error IOException " + e1.getMessage());
            return ERROR_BLUETOOTH_CONNECTION;
        }
    }

    @TargetApi(Build.VERSION_CODES.ECLAIR)
    protected boolean DisconnectFromBT() {
        EnableAssistentThread(false);
        EnableParserThread(false);
        EnableCaptureBluetoothThread(false);
        LogMe.d(LOG_TAG, "Stop ECG , Disconnect from Bluetooth, Stop all threads");
        try {
            if (blueToothSocket != null) {
                if (ecgProtocol != null)
                    ecgProtocol.SendCommand(ECG12_COMMAND.STOP);
                try {
                    Thread.sleep(100); //TODO Check if no need more time for send data to host
                } catch (Exception e) {
                    LogMe.e(LOG_TAG, "Exception " + e.getMessage());
                }
                blueToothSocket.close();
                if (blueToothSocket.getInputStream() != null)
                    blueToothSocket.getInputStream().close();
                if (blueToothSocket.getInputStream() != null)
                    blueToothSocket.getInputStream().close();
                blueToothSocket.close();
                blueToothSocket = null;
            }
            ecgProtocol.FreeAndClose();
        } catch (IOException | InterruptedException e) {
            LogMe.e(LOG_TAG, "Error Stop ECG , Disconnect from Bluetooth, Stop all threads IO error:" + e.getMessage());
            return false;
        }
        return true;
    }

    InputStream in;
    OutputStream out;

    @TargetApi(Build.VERSION_CODES.ECLAIR)
    private void EnableCaptureBluetoothThread(boolean enable) {
        if (enable) {
            try {
                in = blueToothSocket.getInputStream();
                out = blueToothSocket.getOutputStream();
            } catch (Exception e) {
            }
            if (threadCaptureBluetoothData == null) {
                threadCaptureBluetoothData = new Thread(new TaskCaptureBluetoothData());
                threadCaptureBluetoothData.setPriority(Thread.MAX_PRIORITY );
                threadCaptureBluetoothData.start();
            } else {
                if (!threadCaptureBluetoothData.isAlive())
                    threadCaptureBluetoothData.start();
            }
            isCaptureBluetoothThreadOn = true;
        } else {
            if (threadCaptureBluetoothData != null)
                threadCaptureBluetoothData.interrupt();
            threadCaptureBluetoothData = null;
            isCaptureBluetoothThreadOn = false;
        }
    }

    public void EnableParserThread(boolean enable) {
        if (enable) {
            if (threadParceringBluetoothData == null) {
                threadParceringBluetoothData = new Thread(new TaskParceringBluetoothData());
                threadParceringBluetoothData.start();
            } else {
                if (!threadParceringBluetoothData.isAlive())
                    threadParceringBluetoothData.start();
            }
            isParserThreadOn = true;
        } else {
            //TODO  Check  stop pacer thread
            isParserThreadOn = false;
            if (threadParceringBluetoothData != null)
                threadParceringBluetoothData.interrupt();
            threadParceringBluetoothData = null;
        }
    }

    void EnableAssistentThread(boolean enable) {
        if (enable) {
            inBtQueue.clear();
            inParcerQueue.clear();
            rawData.clear();
            if (threadAssistantEcgData == null) {
                threadAssistantEcgData = new Thread(new TaskAssistEcgState());
                threadAssistantEcgData.start();
            } else {
                if (!threadAssistantEcgData.isAlive())
                    threadAssistantEcgData.start();
            }
            isAssistEcgStateOn = true;
        } else {
            isAssistEcgStateOn = false;
            if (threadAssistantEcgData != null) {
                threadAssistantEcgData.interrupt();
            }
            threadAssistantEcgData = null;
        }
        if (isAssistEcgStateOn)
            sleepCaptureData = 0;
        else
            sleepCaptureData = SLEEP_CAPTURE_DATA;
    }

    class TaskCaptureBluetoothData implements Runnable {
        @TargetApi(Build.VERSION_CODES.ECLAIR)
        @Override
        public void run() {
            LogMe.d(LOG_TAG, "Service TaskCaptureBluetoothData Run");
            if (blueToothSocket == null) {
                EnableParserThread(false);
                EnableCaptureBluetoothThread(false);
            }
            try {
                if (blueToothSocket != null)
                    if (blueToothSocket.getInputStream() != null)
                        blueToothSocket.getInputStream().skip(blueToothSocket.getInputStream().available());
            } catch (IOException e) {
                LogMe.e(LOG_TAG, "blueToothSocket.getInputStream().reset - " + e.getMessage());
            }

            while (isCaptureBluetoothThreadOn) {
                if (isCaptureBluetoothThreadOn)
                    ReadDataFromBT();
            }
        }
    }

    int max_read = 0;

    @TargetApi(Build.VERSION_CODES.M)
    void ReadDataFromBT() {
        if (blueToothSocket != null)
            try {
                //
                int availableBytes = 0;
                try {
                    availableBytes = in.available(); //blueToothSocket.getInputStream().available();
                } catch (Exception e) {
                    LogMe.e(LOG_TAG, "Error reading from input stream");
                    return;
                }
                int minByteInReadBuffer = 10; // old value 7
                if (  !inReadMode && (availableBytes >= minByteInReadBuffer)) {
                    //if ( availableBytes > 600)  availableBytes = 600;
                    byte[] bufferReadData = new byte[availableBytes];
                    int count = in.read(bufferReadData, 0, availableBytes);//blueToothSocket.getInputStream().read(bufferReadData, 0, availableBytes);
                    if (count > 0) {
                        for (int j = 0; j < count; j++) {
                            inBtQueue.put(bufferReadData[j]);
                            rawData.put(bufferReadData[j]);
                        }
                        //lock.unlock();
                        LogMe.d(LOG_TAG, "Unlock and stop reading dt data in size "+inBtQueue.size());
                    }
                    if ( count > max_read )
                        max_read = count;
                    if (count > 1000) {
                        LogMe.e(LOG_TAG, "max - read  :  " + max_read +" - "+count+ " size :"+blueToothSocket.getMaxTransmitPacketSize()+"/"+blueToothSocket.getMaxTransmitPacketSize());
                    }else
                        LogMe.d(LOG_TAG, "max - read  :  " + max_read +" - "+count+ " size :"+blueToothSocket.getMaxTransmitPacketSize()+"/"+blueToothSocket.getMaxTransmitPacketSize());
                }

            } catch (Exception e) {
                LogMe.e(LOG_TAG, "Exception TaskCaptureBluetoothData - errorMessage ");
            }
    }

    class TaskParceringBluetoothData implements Runnable {
        @Override
        public void run() {
            LogMe.d(LOG_TAG, "Service TaskParceringBluetoothData Run");
            inReadMode = false;
            while (isParserThreadOn) {
                if (!isParserThreadOn)
                    break;
                try {
                    threadParceringBluetoothData.sleep(THREAD_SLEEP);
                } catch (InterruptedException e) {
                    LogMe.e(LOG_TAG, " Thread.sleep(THREAD_SLEEP) error " + isParserThreadOn + " " + e.getMessage());
                }
                try {
                    if ( inBtQueue != null)
                        if (inBtQueue.size() > 0)
                            DeParserEcgQueue();

                } catch (InterruptedException e) {
                    LogMe.e(LOG_TAG, " DeParserEcgQueue error " + e.getMessage());
                }
                finally {

                }
            }
        }
    }

    class TaskAssistEcgState implements Runnable {
        @Override

        public void run() {
            int martixIndex = 0;     // current state from All glove electrode
            int martixIndexPrev = 0; // prev state
            int matrixIndexSaved = 0;//  save state index for display
            int matrixIndexCounterSaved = 0;

            int totalCounter = 0;
            int waitRemoveGlove = 0;
            int waitForRecordCount = 0;
            int waitForRecordTotalCount = 0;
            int timeOutCounter = 0;
            String messNextTime;
            //String messGloveRemove;

            Bundle bundle = new Bundle();
            Bundle bandleEcgState = new Bundle();
            currentAssistEcgState = AssistEcgState.START_ASSIST;

            LogMe.d(LOG_TAG, "TaskAssistEcgState start run thread loop");
            while (isAssistEcgStateOn) {  //isAssistEcgStateOn
                bundle.clear();
                if (ecgDataView == null) {
                    EnableAssistentThread(false);
                    srv.sendMessage(EcgDataService.ECG_MSG_REC_ASSISTANT_STOPPED, null);
                    break;
                }

                prevAssistEcgState = currentAssistEcgState;
                martixIndexPrev = martixIndex;

                bandleEcgState.clear();


                switch (currentAssistEcgState) {
                    case START_ASSIST:
                        currentAssistEcgState = AssistEcgState.WAIT_FOR_RECORD;
                        martixIndex = 0;
                        timeOutCounter = 0;
                        // messNextTime = GetMessageStringByMatrixId(martixIndex, 3);
                        waitForRecordCount = TIME_OUT_NEXT_MESSAGE_SEC; //Alex Integer.decode(messNextTime);
                        LogMe.d(LOG_TAG, "start_assist");
                        break;

                    case WAIT_FOR_RECORD:
                        martixIndex = ecgDataView.GetEcgStateMartixValue();
                        if ( martixIndex < 0)
                            martixIndex = martixIndexPrev;
                        --waitForRecordCount;
                        timeOutCounter++;
                        if (martixIndex == martixIndexPrev)
                            matrixIndexCounterSaved++;

                        LogMe.d(LOG_TAG, "Matrix Value/Prev = " + martixIndex + "/" + martixIndexPrev + " wait_for_record to be " + waitForRecordCount + " timeout - " + timeOutCounter);

                        if (martixIndex == ecgDataView.MATRIX_INDX_START_RECORDING) {
                            currentAssistEcgState = AssistEcgState.RECORDING;
                            bundle.putInt("MARTIX", martixIndex);
                            srv.sendMessage(srv.ECG_MSG_AUTO_REC_ASSISTANT, bundle);
                            bandleEcgState.putInt("REC_STATUS", ecgDataView.GetEcgStateMartixValue());
                            srv.sendMessage(srv.ECG_MSG_RECORDING_STATUS, bandleEcgState);
                            break;
                        }

                        //Detect all electrode contact is good  send message to user
                        if ((martixIndex == 6) && (martixIndex!=matrixIndexSaved) &&  (matrixIndexCounterSaved >= 2/*MARTIX_DELAY_SEC_BEFORE_SEND*/)) {
                            matrixIndexSaved = martixIndex;
                            bandleEcgState.putInt("REC_STATUS", martixIndex);
                            srv.sendMessage(srv.ECG_MSG_RECORDING_STATUS, bandleEcgState);
                            waitForRecordCount = TIME_OUT_NEXT_MESSAGE_SEC;
                            matrixIndexCounterSaved = 0;
                            break;
                        }
                        if ((martixIndex != 6) && (martixIndex!=matrixIndexSaved) &&  (matrixIndexCounterSaved >= MARTIX_DELAY_SEC_BEFORE_SEND)) {
                            matrixIndexSaved = martixIndex;
                            bandleEcgState.putInt("REC_STATUS", martixIndex);
                            srv.sendMessage(srv.ECG_MSG_RECORDING_STATUS, bandleEcgState);
                            waitForRecordCount = TIME_OUT_NEXT_MESSAGE_SEC;
                            matrixIndexCounterSaved = 0;
                            break;
                        }

                        if (timeOutCounter > TIME_OUT_WAIT_RECORDING_SEC) {
                            LogMe.e(LOG_TAG, "Time OUT !!!");
                            srv.StopAutoRecording();
                            srv.sendMessage(srv.ECG_MSG_TIME_OUT, null);
                            break;
                        }

                        if (waitForRecordCount < 0) {
                            waitForRecordCount = TIME_OUT_NEXT_MESSAGE_SEC;
                            matrixIndexCounterSaved = 0;
                            if ( martixIndex<0)
                                martixIndex = matrixIndexSaved;
                            matrixIndexSaved =-1;
                            bandleEcgState.putInt("REC_STATUS", martixIndex);
                            srv.sendMessage(srv.ECG_MSG_RECORDING_STATUS, bandleEcgState);
                            LogMe.d(LOG_TAG, "NEW STATE Send new MATRIX  : " + martixIndex);
                        }

                        if (timeOutCounter < SENS_HI_WAIT_SEC)
                            ecgDataView.SetSensitivityLevel(SENS_HI_MISS_LEADS);
                        else
                            ecgDataView.SetSensitivityLevel(Integer.parseInt(sens_level));
                      /*  else if (timeOutCounter < (SENS_HI_WAIT_SEC + SENS_MED_WAIT_SEC))
                            ecgDataView.SetSensitivityLevel(SENS_MED_MISS_LEADS);
                        else
                            ecgDataView.SetSensitivityLevel(SENS_LOW_MISS_LEADS);*/

                        break;

                    case RECORDING:
                        timeOutCounter = 0;
                        martixIndex = ecgDataView.GetEcgStateMartixValue();
                        LogMe.i(LOG_TAG, "wait_for_END_record status " + martixIndex);
                        if (martixIndex == ecgDataView.MATRIX_INDX_RECORDED) {
                            messNextTime = "0";
                            RecordEcgViaAssistant();
                        }
                        break;

                    case END_ASSIST:
                        timeOutCounter = 0;
                        LogMe.w(LOG_TAG, "end_assist");
                        srv.StopAutoRecording();
                        break;

                    default:
                        break;
                }
                LogMe.d(LOG_TAG, "TotalCounter before sleep " + totalCounter);
                totalCounter++;

                try {
                    threadAssistantEcgData.sleep(1000);  // 1 sec delay
                } catch (InterruptedException e) {
                    LogMe.e(LOG_TAG, "threadAssistantEcgData.sleep " + e.getMessage());
                }
            }
        }
    }

    private void RecordEcgViaAssistant() {

        currentAssistEcgState = AssistEcgState.END_ASSIST;
        //Alex check now EnableAssistentThread(false);
        LogMe.d(LOG_TAG, "RecordEcgViaAssistant END record , status " + ecgDataView.MATRIX_INDX_RECORDED);

        srv.StopAutoRecording();
        srv.StopEcgCapt();

        Bundle bandle2 = new Bundle();
        bandle2.putInt("REC_STATUS", ecgDataView.MATRIX_INDX_RECORDED);
        srv.sendMessage(srv.ECG_MSG_RECORDING_STATUS, bandle2);
    }

    private void SendProgressScore(int score) {
        Bundle b = new Bundle();
        b.putInt("PROGRESS", score);
        srv.sendMessage(srv.ECG_MSG_AUTO_REC_ASSISTANT, b);
    }


    public boolean isAssistEcgStateOn() {
        return isAssistEcgStateOn;
    }

    public boolean isParserThreadOn() {
        return isParserThreadOn;
    }


    //TODO  remove this proceure from service to client  by get martix id from message
    private String GetMessageStringByMatrixId(int id, int state) {
        String findRes = "";

        switch (state) {
            case 1:
                findRes = "mtrix_status_id_";
                break;
            case 2:
                findRes = "mtrix_message_id_";
                break;
            case 3:
                findRes = "mtrix_time_id_";
                break;
            case 4:
                findRes = "mtrix_wait_for_glove_id_";
                break;
            default:
                break;
        }

        int ind_id = mContext.getResources().getIdentifier(findRes + String.valueOf(id), "string", mContext.getPackageName());
        if (ind_id > 0)
            return mContext.getString(ind_id);
        else
            return "";
    }

    //region procedures -> Read data from bluetooth socket and parsering
    // private synchronized  void DeParserEcgQueue() throws InterruptedException {
    private void DeParserEcgQueue() throws InterruptedException {
        byte lsb, msb, currDataLen, checkSumHeader;
        boolean checkCurrPacket;
        int[] leadData = new int[DATA_LENGTH / 2];
        byte[] rawFaultLeadData = new byte[FAULT_DATA_LENGTH];
        byte[] rawBattLevelData = new byte[BATT_LEVEL_LENGTH];
        byte[] rawHardVersionData = new byte[8];
        short[] sample;
        int sumChkSumHeader, sumChkSumData, currPacketSeq;
        int indxInPacketArr;
        Byte[] packetArray;
        byte seqLsbHead, seqMsbHead, sourceHead, destHead, trasfHead;
        int sumChkSumData2;
        boolean checkCurrData;

        if (inBtQueue.size() < 10)
            return;
        if (inReadMode)
            return;

        inReadMode = true;

        // need to add data to parser queue
        LogMe.d(LOG_TAG,"DeParserEcgQueue start 1. Incomming buffer: "+inBtQueue.size()+" Parser buffer: "+inParcerQueue.size());
        try {
            inBtQueue.drainTo(inParcerQueue, inBtQueue.size()); //   needForPacket = inBtQueue.size();   for (int i=0;i<needForPacket;i++ )  inParcerQueue.add(inBtQueue.poll());
        } catch (Exception e) {
            LogMe.e(LOG_TAG, "inBtQueue.drainTo bug , message: " + e.toString());
            return;
        }
        LogMe.d(LOG_TAG,"DeParserEcgQueue start 2. Incomming buffer: "+inBtQueue.size()+" Parser buffer: "+inParcerQueue.size());
        // convert data from queue to header array
        packetArray = (Byte[]) inParcerQueue.toArray(new Byte[0]);


        indxInPacketArr = 0;

        do {
            // check header
            sourceHead = packetArray[HEADER_INDX_DESTINATION + indxInPacketArr];
            destHead = packetArray[HEADER_INDX_SOURCE + indxInPacketArr];
            trasfHead = packetArray[HEADER_INDX_TRASFER_TYPE + indxInPacketArr];
            seqLsbHead = packetArray[HEADER_INDX_SEQ_LSB + indxInPacketArr];
            seqMsbHead = packetArray[HEADER_INDX_SEQ_MSB + indxInPacketArr];
            currPacketSeq = ((int) seqMsbHead << 8) | ((int) seqLsbHead & 0xFF);
            currDataLen = packetArray[HEADER_INDX_DATA_LENGTH + indxInPacketArr];
            checkSumHeader = packetArray[HEADER_INDX_DATA_CHKSUM + indxInPacketArr];

            checkCurrPacket = false;
            if ((sourceHead == HEADER_SOURCE) && (destHead == HEADER_DESTINATION)) {
                if ((trasfHead == HEADER_DATA_TRASFER_TYPE) || (trasfHead == HEADER_FAULT_TRASFER_TYPE) ||
                        (trasfHead == HEADER_BATT_LEVEL_CMD) || (trasfHead == HEADER_GLOVE_TYPE) || (trasfHead == HEADER_GLOVE_VERSION)) {
                    sumChkSumHeader = sourceHead + destHead + trasfHead + seqLsbHead + seqMsbHead + currDataLen + checkSumHeader;
                    if ((sumChkSumHeader & 0xFF) == 0) {
                        checkCurrPacket = true;
                    } else {
                        LogMe.e(LOG_TAG, "Cheksum Header ERROR packet: " + Integer.toHexString(sourceHead) + " | " + Integer.toHexString(destHead) + " | " +
                                Integer.toHexString(trasfHead) + " | " + Integer.toHexString(currDataLen) + " | " + Integer.toHexString(seqLsbHead) + " | " +
                                Integer.toHexString(seqMsbHead) + " | " + Integer.toHexString(currDataLen) + " | " + Integer.toHexString(checkSumHeader) +  "Inc index +1 Continue");
                        indxInPacketArr += 1;
                        continue;
                    }
                } else {
                    LogMe.e(LOG_TAG,"Packet from unknown source !!!  - seq packets " + prevPacket + "/"+currPack+" Inc index +1 Continue : "+    indxInPacketArr);
                    indxInPacketArr += 1;
                    continue;
                }
            }else{
                indxInPacketArr += 1;
                LogMe.w(LOG_TAG, "Packet header destination unknow 1 - seq packets " + prevPacket + "/"+currPack+" Inc index +1 Continue : "+    indxInPacketArr );
                continue;
            }


            //  check if data avalieble if not Don't remove data and exit from loop
            if (checkCurrPacket) {
                if (packetArray.length < indxInPacketArr + HEADER_LENGTH + currDataLen + 1) {
                    //LogMe.i(LOG_TAG, " Packet Ok but data not complete in packet : Total length is: " + packetArray.length + " need : start is: " + indxInPacketArr + " offset 7 + "+currDataLen);
                    break;
                }
            }

            //check data if OK ?
            checkCurrData = false;
            sumChkSumData = 0;
            String log_packet = "";
            if (checkCurrPacket) {
                for (int i = 0; i < currDataLen - 1; i++) {
                    sumChkSumData += packetArray[indxInPacketArr + HEADER_LENGTH + i];
                    log_packet = log_packet + Integer.toHexString(packetArray[indxInPacketArr + HEADER_LENGTH + i]) +" ";
                }
                sumChkSumData2 = packetArray[indxInPacketArr + currDataLen + HEADER_LENGTH - 1];
                sumChkSumData += sumChkSumData2;
                checkCurrData = ((sumChkSumData & 0xFF) == 0);
                log_packet = log_packet + " CHECKSUM : "+ Integer.toHexString(sumChkSumData2)+" "+ Integer.toHexString(sumChkSumData) + " "+checkCurrData;
                if (!checkCurrData) {
                    LogMe.w(LOG_TAG, "Checksum of data packet Error 1 - s/d" + sourceHead + " /  "+ destHead + " type: "+trasfHead + " len: "+currDataLen);
                    LogMe.w(LOG_TAG, "Checksum of data packet Error 2 - seq packets " + prevPacket + "/"+currPack);
                    LogMe.w(LOG_TAG, "Checksum of data packet Error 3 - " + currPacketSeq + "packet : "+log_packet + "   Inc index +1 Continue");
                    indxInPacketArr += 1;
                    continue;
                }else{
                    LogMe.d(LOG_TAG, "Packet data OK 1 - s/d" + sourceHead + " /  "+ destHead + " type: "+trasfHead + " len: "+currDataLen+" seq packets " + prevPacket + "/"+currPack+"/"+currPacketSeq);
                }
            }else{
                LogMe.w(LOG_TAG, "Packet not completed 1 - s/d" + sourceHead + " /  "+ destHead + " type: "+trasfHead + " len: "+currDataLen);
                LogMe.w(LOG_TAG, "Packet not completed  2 - seq packets " + prevPacket + "/"+currPack+"/"+currPacketSeq);
                indxInPacketArr += 1;
                continue;
            }

            // get and parcer data from array
            if (checkCurrPacket && checkCurrData) {
                prevPacket = currPack;
                currPack = currPacketSeq;
                if ((currPack - prevPacket) > 1) {
                    LogMe.e(LOG_TAG, "LOST packets !  from  " + prevPacket + " until " + currPack + " lost : " + String.valueOf((currPack - prevPacket) + " packets"));
                    prevPacket = currPack;
                }
                // for ECG data
                if (trasfHead == HEADER_DATA_TRASFER_TYPE) {
                    int count = 0;
                    LogMe.d(LOG_TAG, "Packet type HEADER_DATA_TRASFER_TYPE !!!");
                    for (int i = 0; i < DATA_LENGTH; i += 2) {
                        lsb = packetArray[indxInPacketArr + HEADER_LENGTH + i];
                        msb = packetArray[indxInPacketArr + HEADER_LENGTH + i + 1];
                        int data = ((int) msb << 8) | ((int) lsb & 0xFF);
                        leadData[count++] = (short) data;
                    }
                    if ( ecgDataView != null) {
                        ecgDataView.SetNewDataPacket(leadData, currPack);
                    }
                }
                int score = 0;
                // for ECG  fault data
                if (trasfHead == HEADER_FAULT_TRASFER_TYPE) {
                    LogMe.d(LOG_TAG, "Packet type HEADER_FAULT_TRASFER_TYPEd !!!");
                    rawFaultLeadData[0] = packetArray[indxInPacketArr + HEADER_LENGTH];
                    rawFaultLeadData[1] = packetArray[indxInPacketArr + HEADER_LENGTH + 1];
                    if ((rawFaultLeadData[0] == 27) && (rawFaultLeadData[1] == 15)) {
                        rawFaultLeadData[0] = 31;
                    }
                    if ( ecgDataView != null) {
                        ecgDataView.AddFaultStatus(rawFaultLeadData);
                        score = ecgDataView.GetProgressScore();

                        //TODO   Send status update
                        if (isAssistEcgStateOn())
                            SendProgressScore(score);
                        //sendMessageToUI(this.MSG_STATUS_UPDATE, Integer.toString(score), "", "", "");
                    }


                    StringBuilder sb = new StringBuilder();
                    for (byte tb : rawFaultLeadData)
                        sb.append(tb).append(" ");
                    Bundle bundle = new Bundle();
                    bundle.putString("FAULT_LEAD", ecgDataView.currentFaultState);
                    // bundle.putString("STABLE_LEAD", ecgDataView.GetStableLead());
                    if (!ecgDataView.currentFaultState.equals(ecgDataView.prevFaultState))
                        srv.sendMessage(srv.ECG_MSG_ELECTRODE_STATUS, bundle);
                    // LogMe.i("fault", "Packet Fault  data - " + sb.toString());


                    String prevStableState = ecgDataView.prevStableState;
                    //TODO bug !!!
                    if (!ecgDataView.GetStableLead().equals(prevStableState))
                    {
                        Bundle bundle2 = new Bundle();
                        bundle2.putString("STABLE_LEAD", ecgDataView.GetStableLead());
                        srv.sendMessage(srv.ECG_MSG_ELECTRODE_STABLE, bundle2);
                        if ((score == 0) && (isAssistEcgStateOn())) {
                            score = ecgDataView.GetProgressScore();
                            SendProgressScore(score);
                        }
                    }

                }

                // for glove battery level
                if (trasfHead == HEADER_GLOVE_VERSION) {
                    LogMe.d(LOG_TAG, "Hardware version  packet found !!!");
                    rawHardVersionData[0] = packetArray[indxInPacketArr + HEADER_LENGTH];
                    rawHardVersionData[1] = packetArray[indxInPacketArr + HEADER_LENGTH + 1];
                    rawHardVersionData[2] = packetArray[indxInPacketArr + HEADER_LENGTH + 2];
                    rawHardVersionData[3] = packetArray[indxInPacketArr + HEADER_LENGTH + 3];
                    rawHardVersionData[4] = packetArray[indxInPacketArr + HEADER_LENGTH + 4];
                    rawHardVersionData[5] = packetArray[indxInPacketArr + HEADER_LENGTH + 5];
                    rawHardVersionData[6] = packetArray[indxInPacketArr + HEADER_LENGTH + 6];
                    rawHardVersionData[7] = packetArray[indxInPacketArr + HEADER_LENGTH + 7];
                   // StringBuilder sb = new StringBuilder();
                    hardwareVersion = new String(rawHardVersionData);
                }


                // for glove battery level
                if (trasfHead == HEADER_BATT_LEVEL_CMD) {
                    LogMe.d(LOG_TAG, "Battery packet found !!!");
                    rawBattLevelData[0] = packetArray[indxInPacketArr + HEADER_LENGTH];
                    rawBattLevelData[1] = packetArray[indxInPacketArr + HEADER_LENGTH + 1];
                    StringBuilder sb = new StringBuilder();
                    for (byte tb : rawBattLevelData)
                        sb.append(tb).append(" ");
                    byte msbBatt = rawBattLevelData[1];
                    byte lsbBatt = rawBattLevelData[0];
                    int battLevel = 0;
                    double battfLevel = 0;
                    String statusBat = "N/A";
                    battLevel = msbBatt << 8;
                    battLevel = battLevel + lsbBatt;
                    battfLevel = battLevel / 3;
                    battfLevel = battfLevel / 4096;
                    ;
                    battfLevel = battfLevel * 3.3;
                    if (battfLevel > LevelBattHi)
                        statusBat = "Full";
                    if ((battfLevel > LevelBattMed) && (battfLevel < LevelBattHi))
                        statusBat = "Medium";
                    if ((battfLevel > LevelBattLow) && (battfLevel < LevelBattMed))
                        statusBat = "Low";
                    if (battfLevel < LevelBattLow)
                        statusBat = "Empty";
                    String battMV = String.format("%.3f", battfLevel) + "mV";
                    Bundle bundle = new Bundle();
                    if ((battfLevel > 0) && (battMV != null)) {
                        bundle.putString("BATT_LEVEL", statusBat); //String.valueOf(battfLevel));
                        bundle.putString("BATT_VOLTAGE", battMV); //String.valueOf(battfLevel));
                    } else {
                        bundle.putString("BATT_LEVEL", "n/a"); //String.valueOf(battfLevel));
                        bundle.putString("BATT_VOLTAGE", "n/a"); //String.valueOf(battfLevel));
                    }
                    LogMe.d(LOG_TAG, "Server prepare to send battery data out");
                    srv.sendMessage(srv.ECG_MSG_BATTARY_LEVEL, bundle);
                }
            }
            if (checkCurrPacket && checkCurrData)
                indxInPacketArr = indxInPacketArr + (currDataLen + HEADER_LENGTH );
            else
                indxInPacketArr += 1;

            LogMe.d(LOG_TAG, "Packet old: " + prevPacket + " packet new: " + currPack+ " new step: "+indxInPacketArr);

        } while (indxInPacketArr < packetArray.length - 8);


        //TODO set max time for loop !!!

        for (int i = 0; i < indxInPacketArr; i++)
            inParcerQueue.poll(0, TimeUnit.MICROSECONDS);

        LogMe.d(LOG_TAG,"DeParserEcgQueue end. Remove  "+indxInPacketArr+ " from queue. Curretn incomming buffer: "+inParcerQueue.size());

        inReadMode = false;
    }

    //endregion

}
